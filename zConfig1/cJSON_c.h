char *cJSON_c =
"/*\n"
"  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors\n"
"\n"
"  Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"  of this software and associated documentation files (the \"Software\"), to deal\n"
"  in the Software without restriction, including without limitation the rights\n"
"  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"  copies of the Software, and to permit persons to whom the Software is\n"
"  furnished to do so, subject to the following conditions:\n"
"\n"
"  The above copyright notice and this permission notice shall be included in\n"
"  all copies or substantial portions of the Software.\n"
"\n"
"  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
"  THE SOFTWARE.\n"
"*/\n"
"\n"
"/* cJSON */\n"
"/* JSON parser in C. */\n"
"\n"
"#ifdef __GNUC__\n"
"#pragma GCC visibility push(default)\n"
"#endif\n"
"\n"
"#include <string.h>\n"
"#include <stdio.h>\n"
"#include <math.h>\n"
"#include <stdlib.h>\n"
"#include <float.h>\n"
"#include <limits.h>\n"
"#include <ctype.h>\n"
"#include <locale.h>\n"
"\n"
"#ifdef __GNUC__\n"
"#pragma GCC visibility pop\n"
"#endif\n"
"\n"
"#include \"cJSON.h\"\n"
"\n"
"/* define our own boolean type */\n"
"#define true ((cJSON_bool)1)\n"
"#define false ((cJSON_bool)0)\n"
"\n"
"typedef struct {\n"
"    const unsigned char *json;\n"
"    size_t position;\n"
"} error;\n"
"static error global_error = { NULL, 0 };\n"
"\n"
"CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)\n"
"{\n"
"    return (const char*) (global_error.json + global_error.position);\n"
"}\n"
"\n"
"/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */\n"
"#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 5) || (CJSON_VERSION_PATCH != 9)\n"
"    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.\n"
"#endif\n"
"\n"
"CJSON_PUBLIC(const char*) cJSON_Version(void)\n"
"{\n"
"    static char version[15];\n"
"    sprintf(version, \"%i.%i.%i\", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);\n"
"\n"
"    return version;\n"
"}\n"
"\n"
"/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */\n"
"static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)\n"
"{\n"
"    if ((string1 == NULL) || (string2 == NULL))\n"
"    {\n"
"        return 1;\n"
"    }\n"
"\n"
"    if (string1 == string2)\n"
"    {\n"
"        return 0;\n"
"    }\n"
"\n"
"    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)\n"
"    {\n"
"        if (*string1 == '\\0')\n"
"        {\n"
"            return 0;\n"
"        }\n"
"    }\n"
"\n"
"    return tolower(*string1) - tolower(*string2);\n"
"}\n"
"\n"
"typedef struct internal_hooks\n"
"{\n"
"    void *(*allocate)(size_t size);\n"
"    void (*deallocate)(void *pointer);\n"
"    void *(*reallocate)(void *pointer, size_t size);\n"
"} internal_hooks;\n"
"\n"
"static internal_hooks global_hooks = { malloc, free, realloc };\n"
"\n"
"static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)\n"
"{\n"
"    size_t length = 0;\n"
"    unsigned char *copy = NULL;\n"
"\n"
"    if (string == NULL)\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    length = strlen((const char*)string) + sizeof(\"\");\n"
"    if (!(copy = (unsigned char*)hooks->allocate(length)))\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"    memcpy(copy, string, length);\n"
"\n"
"    return copy;\n"
"}\n"
"\n"
"CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)\n"
"{\n"
"    if (hooks == NULL)\n"
"    {\n"
"        /* Reset hooks */\n"
"        global_hooks.allocate = malloc;\n"
"        global_hooks.deallocate = free;\n"
"        global_hooks.reallocate = realloc;\n"
"        return;\n"
"    }\n"
"\n"
"    global_hooks.allocate = malloc;\n"
"    if (hooks->malloc_fn != NULL)\n"
"    {\n"
"        global_hooks.allocate = hooks->malloc_fn;\n"
"    }\n"
"\n"
"    global_hooks.deallocate = free;\n"
"    if (hooks->free_fn != NULL)\n"
"    {\n"
"        global_hooks.deallocate = hooks->free_fn;\n"
"    }\n"
"\n"
"    /* use realloc only if both free and malloc are used */\n"
"    global_hooks.reallocate = NULL;\n"
"    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))\n"
"    {\n"
"        global_hooks.reallocate = realloc;\n"
"    }\n"
"}\n"
"\n"
"/* Internal constructor. */\n"
"static cJSON *cJSON_New_Item(const internal_hooks * const hooks)\n"
"{\n"
"    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));\n"
"    if (node)\n"
"    {\n"
"        memset(node, '\\0', sizeof(cJSON));\n"
"    }\n"
"\n"
"    return node;\n"
"}\n"
"\n"
"/* Delete a cJSON structure. */\n"
"CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)\n"
"{\n"
"    cJSON *next = NULL;\n"
"    while (item != NULL)\n"
"    {\n"
"        next = item->next;\n"
"        if (!(item->type & cJSON_IsReference) && (item->child != NULL))\n"
"        {\n"
"            cJSON_Delete(item->child);\n"
"        }\n"
"        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))\n"
"        {\n"
"            global_hooks.deallocate(item->valuestring);\n"
"        }\n"
"        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n"
"        {\n"
"            global_hooks.deallocate(item->string);\n"
"        }\n"
"        global_hooks.deallocate(item);\n"
"        item = next;\n"
"    }\n"
"}\n"
"\n"
"/* get the decimal point character of the current locale */\n"
"static unsigned char get_decimal_point(void)\n"
"{\n"
"    struct lconv *lconv = localeconv();\n"
"    return (unsigned char) lconv->decimal_point[0];\n"
"}\n"
"\n"
"typedef struct\n"
"{\n"
"    const unsigned char *content;\n"
"    size_t length;\n"
"    size_t offset;\n"
"    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */\n"
"    internal_hooks hooks;\n"
"} parse_buffer;\n"
"\n"
"/* check if the given size is left to read in a given parse buffer (starting with 1) */\n"
"#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))\n"
"#define cannot_read(buffer, size) (!can_read(buffer, size))\n"
"/* check if the buffer can be accessed at the given index (starting with 0) */\n"
"#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))\n"
"#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))\n"
"/* get a pointer to the buffer at the position */\n"
"#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)\n"
"\n"
"/* Parse the input text to generate a number, and populate the result into item. */\n"
"static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)\n"
"{\n"
"    double number = 0;\n"
"    unsigned char *after_end = NULL;\n"
"    unsigned char number_c_string[64];\n"
"    unsigned char decimal_point = get_decimal_point();\n"
"    size_t i = 0;\n"
"\n"
"    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    /* copy the number into a temporary buffer and replace '.' with the decimal point\n"
"     * of the current locale (for strtod)\n"
"     * This also takes care of '\\0' not necessarily being available for marking the end of the input */\n"
"    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)\n"
"    {\n"
"        switch (buffer_at_offset(input_buffer)[i])\n"
"        {\n"
"            case '0':\n"
"            case '1':\n"
"            case '2':\n"
"            case '3':\n"
"            case '4':\n"
"            case '5':\n"
"            case '6':\n"
"            case '7':\n"
"            case '8':\n"
"            case '9':\n"
"            case '+':\n"
"            case '-':\n"
"            case 'e':\n"
"            case 'E':\n"
"                number_c_string[i] = buffer_at_offset(input_buffer)[i];\n"
"                break;\n"
"\n"
"            case '.':\n"
"                number_c_string[i] = decimal_point;\n"
"                break;\n"
"\n"
"            default:\n"
"                goto loop_end;\n"
"        }\n"
"    }\n"
"loop_end:\n"
"    number_c_string[i] = '\\0';\n"
"\n"
"    number = strtod((const char*)number_c_string, (char**)&after_end);\n"
"    if (number_c_string == after_end)\n"
"    {\n"
"        return false; /* parse_error */\n"
"    }\n"
"\n"
"    item->valuedouble = number;\n"
"\n"
"    /* use saturation in case of overflow */\n"
"    if (number >= INT_MAX)\n"
"    {\n"
"        item->valueint = INT_MAX;\n"
"    }\n"
"    else if (number <= INT_MIN)\n"
"    {\n"
"        item->valueint = INT_MIN;\n"
"    }\n"
"    else\n"
"    {\n"
"        item->valueint = (int)number;\n"
"    }\n"
"\n"
"    item->type = cJSON_Number;\n"
"\n"
"    input_buffer->offset += (size_t)(after_end - number_c_string);\n"
"    return true;\n"
"}\n"
"\n"
"/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */\n"
"CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)\n"
"{\n"
"    if (number >= INT_MAX)\n"
"    {\n"
"        object->valueint = INT_MAX;\n"
"    }\n"
"    else if (number <= INT_MIN)\n"
"    {\n"
"        object->valueint = INT_MIN;\n"
"    }\n"
"    else\n"
"    {\n"
"        object->valueint = (int)number;\n"
"    }\n"
"\n"
"    return object->valuedouble = number;\n"
"}\n"
"\n"
"typedef struct\n"
"{\n"
"    unsigned char *buffer;\n"
"    size_t length;\n"
"    size_t offset;\n"
"    size_t depth; /* current nesting depth (for formatted printing) */\n"
"    cJSON_bool noalloc;\n"
"    cJSON_bool format; /* is this print a formatted print */\n"
"    internal_hooks hooks;\n"
"} printbuffer;\n"
"\n"
"/* realloc printbuffer if necessary to have at least \"needed\" bytes more */\n"
"static unsigned char* ensure(printbuffer * const p, size_t needed)\n"
"{\n"
"    unsigned char *newbuffer = NULL;\n"
"    size_t newsize = 0;\n"
"\n"
"    if ((p == NULL) || (p->buffer == NULL))\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    if ((p->length > 0) && (p->offset >= p->length))\n"
"    {\n"
"        /* make sure that offset is valid */\n"
"        return NULL;\n"
"    }\n"
"\n"
"    if (needed > INT_MAX)\n"
"    {\n"
"        /* sizes bigger than INT_MAX are currently not supported */\n"
"        return NULL;\n"
"    }\n"
"\n"
"    needed += p->offset + 1;\n"
"    if (needed <= p->length)\n"
"    {\n"
"        return p->buffer + p->offset;\n"
"    }\n"
"\n"
"    if (p->noalloc) {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    /* calculate new buffer size */\n"
"    if (needed > (INT_MAX / 2))\n"
"    {\n"
"        /* overflow of int, use INT_MAX if possible */\n"
"        if (needed <= INT_MAX)\n"
"        {\n"
"            newsize = INT_MAX;\n"
"        }\n"
"        else\n"
"        {\n"
"            return NULL;\n"
"        }\n"
"    }\n"
"    else\n"
"    {\n"
"        newsize = needed * 2;\n"
"    }\n"
"\n"
"    if (p->hooks.reallocate != NULL)\n"
"    {\n"
"        /* reallocate with realloc if available */\n"
"        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);\n"
"        if (newbuffer == NULL)\n"
"        {\n"
"            p->hooks.deallocate(p->buffer);\n"
"            p->length = 0;\n"
"            p->buffer = NULL;\n"
"\n"
"            return NULL;\n"
"        }\n"
"    }\n"
"    else\n"
"    {\n"
"        /* otherwise reallocate manually */\n"
"        newbuffer = (unsigned char*)p->hooks.allocate(newsize);\n"
"        if (!newbuffer)\n"
"        {\n"
"            p->hooks.deallocate(p->buffer);\n"
"            p->length = 0;\n"
"            p->buffer = NULL;\n"
"\n"
"            return NULL;\n"
"        }\n"
"        if (newbuffer)\n"
"        {\n"
"            memcpy(newbuffer, p->buffer, p->offset + 1);\n"
"        }\n"
"        p->hooks.deallocate(p->buffer);\n"
"    }\n"
"    p->length = newsize;\n"
"    p->buffer = newbuffer;\n"
"\n"
"    return newbuffer + p->offset;\n"
"}\n"
"\n"
"/* calculate the new length of the string in a printbuffer and update the offset */\n"
"static void update_offset(printbuffer * const buffer)\n"
"{\n"
"    const unsigned char *buffer_pointer = NULL;\n"
"    if ((buffer == NULL) || (buffer->buffer == NULL))\n"
"    {\n"
"        return;\n"
"    }\n"
"    buffer_pointer = buffer->buffer + buffer->offset;\n"
"\n"
"    buffer->offset += strlen((const char*)buffer_pointer);\n"
"}\n"
"\n"
"/* Render the number nicely from the given item into a string. */\n"
"static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)\n"
"{\n"
"    unsigned char *output_pointer = NULL;\n"
"    double d = item->valuedouble;\n"
"    int length = 0;\n"
"    size_t i = 0;\n"
"    unsigned char number_buffer[26]; /* temporary buffer to print the number into */\n"
"    unsigned char decimal_point = get_decimal_point();\n"
"    double test;\n"
"\n"
"    if (output_buffer == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    /* This checks for NaN and Infinity */\n"
"    if ((d * 0) != 0)\n"
"    {\n"
"        length = sprintf((char*)number_buffer, \"null\");\n"
"    }\n"
"    else\n"
"    {\n"
"        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */\n"
"        length = sprintf((char*)number_buffer, \"%1.15g\", d);\n"
"\n"
"        /* Check whether the original double can be recovered */\n"
"        if ((sscanf((char*)number_buffer, \"%lg\", &test) != 1) || ((double)test != d))\n"
"        {\n"
"            /* If not, print with 17 decimal places of precision */\n"
"            length = sprintf((char*)number_buffer, \"%1.17g\", d);\n"
"        }\n"
"    }\n"
"\n"
"    /* sprintf failed or buffer overrun occured */\n"
"    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    /* reserve appropriate space in the output */\n"
"    output_pointer = ensure(output_buffer, (size_t)length);\n"
"    if (output_pointer == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    /* copy the printed number to the output and replace locale\n"
"     * dependent decimal point with '.' */\n"
"    for (i = 0; i < ((size_t)length); i++)\n"
"    {\n"
"        if (number_buffer[i] == decimal_point)\n"
"        {\n"
"            output_pointer[i] = '.';\n"
"            continue;\n"
"        }\n"
"\n"
"        output_pointer[i] = number_buffer[i];\n"
"    }\n"
"    output_pointer[i] = '\\0';\n"
"\n"
"    output_buffer->offset += (size_t)length;\n"
"\n"
"    return true;\n"
"}\n"
"\n"
"/* parse 4 digit hexadecimal number */\n"
"static unsigned parse_hex4(const unsigned char * const input)\n"
"{\n"
"    unsigned int h = 0;\n"
"    size_t i = 0;\n"
"\n"
"    for (i = 0; i < 4; i++)\n"
"    {\n"
"        /* parse digit */\n"
"        if ((input[i] >= '0') && (input[i] <= '9'))\n"
"        {\n"
"            h += (unsigned int) input[i] - '0';\n"
"        }\n"
"        else if ((input[i] >= 'A') && (input[i] <= 'F'))\n"
"        {\n"
"            h += (unsigned int) 10 + input[i] - 'A';\n"
"        }\n"
"        else if ((input[i] >= 'a') && (input[i] <= 'f'))\n"
"        {\n"
"            h += (unsigned int) 10 + input[i] - 'a';\n"
"        }\n"
"        else /* invalid */\n"
"        {\n"
"            return 0;\n"
"        }\n"
"\n"
"        if (i < 3)\n"
"        {\n"
"            /* shift left to make place for the next nibble */\n"
"            h = h << 4;\n"
"        }\n"
"    }\n"
"\n"
"    return h;\n"
"}\n"
"\n"
"/* converts a UTF-16 literal to UTF-8\n"
" * A literal can be one or two sequences of the form \\uXXXX */\n"
"static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)\n"
"{\n"
"    long unsigned int codepoint = 0;\n"
"    unsigned int first_code = 0;\n"
"    const unsigned char *first_sequence = input_pointer;\n"
"    unsigned char utf8_length = 0;\n"
"    unsigned char utf8_position = 0;\n"
"    unsigned char sequence_length = 0;\n"
"    unsigned char first_byte_mark = 0;\n"
"\n"
"    if ((input_end - first_sequence) < 6)\n"
"    {\n"
"        /* input ends unexpectedly */\n"
"        goto fail;\n"
"    }\n"
"\n"
"    /* get the first utf16 sequence */\n"
"    first_code = parse_hex4(first_sequence + 2);\n"
"\n"
"    /* check that the code is valid */\n"
"    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))\n"
"    {\n"
"        goto fail;\n"
"    }\n"
"\n"
"    /* UTF16 surrogate pair */\n"
"    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))\n"
"    {\n"
"        const unsigned char *second_sequence = first_sequence + 6;\n"
"        unsigned int second_code = 0;\n"
"        sequence_length = 12; /* \\uXXXX\\uXXXX */\n"
"\n"
"        if ((input_end - second_sequence) < 6)\n"
"        {\n"
"            /* input ends unexpectedly */\n"
"            goto fail;\n"
"        }\n"
"\n"
"        if ((second_sequence[0] != '\\\\') || (second_sequence[1] != 'u'))\n"
"        {\n"
"            /* missing second half of the surrogate pair */\n"
"            goto fail;\n"
"        }\n"
"\n"
"        /* get the second utf16 sequence */\n"
"        second_code = parse_hex4(second_sequence + 2);\n"
"        /* check that the code is valid */\n"
"        if ((second_code < 0xDC00) || (second_code > 0xDFFF))\n"
"        {\n"
"            /* invalid second half of the surrogate pair */\n"
"            goto fail;\n"
"        }\n"
"\n"
"\n"
"        /* calculate the unicode codepoint from the surrogate pair */\n"
"        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));\n"
"    }\n"
"    else\n"
"    {\n"
"        sequence_length = 6; /* \\uXXXX */\n"
"        codepoint = first_code;\n"
"    }\n"
"\n"
"    /* encode as UTF-8\n"
"     * takes at maximum 4 bytes to encode:\n"
"     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */\n"
"    if (codepoint < 0x80)\n"
"    {\n"
"        /* normal ascii, encoding 0xxxxxxx */\n"
"        utf8_length = 1;\n"
"    }\n"
"    else if (codepoint < 0x800)\n"
"    {\n"
"        /* two bytes, encoding 110xxxxx 10xxxxxx */\n"
"        utf8_length = 2;\n"
"        first_byte_mark = 0xC0; /* 11000000 */\n"
"    }\n"
"    else if (codepoint < 0x10000)\n"
"    {\n"
"        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */\n"
"        utf8_length = 3;\n"
"        first_byte_mark = 0xE0; /* 11100000 */\n"
"    }\n"
"    else if (codepoint <= 0x10FFFF)\n"
"    {\n"
"        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */\n"
"        utf8_length = 4;\n"
"        first_byte_mark = 0xF0; /* 11110000 */\n"
"    }\n"
"    else\n"
"    {\n"
"        /* invalid unicode codepoint */\n"
"        goto fail;\n"
"    }\n"
"\n"
"    /* encode as utf8 */\n"
"    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)\n"
"    {\n"
"        /* 10xxxxxx */\n"
"        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);\n"
"        codepoint >>= 6;\n"
"    }\n"
"    /* encode first byte */\n"
"    if (utf8_length > 1)\n"
"    {\n"
"        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);\n"
"    }\n"
"    else\n"
"    {\n"
"        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);\n"
"    }\n"
"\n"
"    *output_pointer += utf8_length;\n"
"\n"
"    return sequence_length;\n"
"\n"
"fail:\n"
"    return 0;\n"
"}\n"
"\n"
"/* Parse the input text into an unescaped cinput, and populate item. */\n"
"static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)\n"
"{\n"
"    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;\n"
"    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;\n"
"    unsigned char *output_pointer = NULL;\n"
"    unsigned char *output = NULL;\n"
"\n"
"    /* not a string */\n"
"    if (buffer_at_offset(input_buffer)[0] != '\\\"')\n"
"    {\n"
"        goto fail;\n"
"    }\n"
"\n"
"    {\n"
"        /* calculate approximate size of the output (overestimate) */\n"
"        size_t allocation_length = 0;\n"
"        size_t skipped_bytes = 0;\n"
"        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\\\"'))\n"
"        {\n"
"            /* is escape sequence */\n"
"            if (input_end[0] == '\\\\')\n"
"            {\n"
"                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)\n"
"                {\n"
"                    /* prevent buffer overflow when last input character is a backslash */\n"
"                    goto fail;\n"
"                }\n"
"                skipped_bytes++;\n"
"                input_end++;\n"
"            }\n"
"            input_end++;\n"
"        }\n"
"        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\\\"'))\n"
"        {\n"
"            goto fail; /* string ended unexpectedly */\n"
"        }\n"
"\n"
"        /* This is at most how much we need for the output */\n"
"        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;\n"
"        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(\"\"));\n"
"        if (output == NULL)\n"
"        {\n"
"            goto fail; /* allocation failure */\n"
"        }\n"
"    }\n"
"\n"
"    output_pointer = output;\n"
"    /* loop through the string literal */\n"
"    while (input_pointer < input_end)\n"
"    {\n"
"        if (*input_pointer != '\\\\')\n"
"        {\n"
"            *output_pointer++ = *input_pointer++;\n"
"        }\n"
"        /* escape sequence */\n"
"        else\n"
"        {\n"
"            unsigned char sequence_length = 2;\n"
"            if ((input_end - input_pointer) < 1)\n"
"            {\n"
"                goto fail;\n"
"            }\n"
"\n"
"            switch (input_pointer[1])\n"
"            {\n"
"                case 'b':\n"
"                    *output_pointer++ = '\\b';\n"
"                    break;\n"
"                case 'f':\n"
"                    *output_pointer++ = '\\f';\n"
"                    break;\n"
"                case 'n':\n"
"                    *output_pointer++ = '\\n';\n"
"                    break;\n"
"                case 'r':\n"
"                    *output_pointer++ = '\\r';\n"
"                    break;\n"
"                case 't':\n"
"                    *output_pointer++ = '\\t';\n"
"                    break;\n"
"                case '\\\"':\n"
"                case '\\\\':\n"
"                case '/':\n"
"                    *output_pointer++ = input_pointer[1];\n"
"                    break;\n"
"\n"
"                /* UTF-16 literal */\n"
"                case 'u':\n"
"                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);\n"
"                    if (sequence_length == 0)\n"
"                    {\n"
"                        /* failed to convert UTF16-literal to UTF-8 */\n"
"                        goto fail;\n"
"                    }\n"
"                    break;\n"
"\n"
"                default:\n"
"                    goto fail;\n"
"            }\n"
"            input_pointer += sequence_length;\n"
"        }\n"
"    }\n"
"\n"
"    /* zero terminate the output */\n"
"    *output_pointer = '\\0';\n"
"\n"
"    item->type = cJSON_String;\n"
"    item->valuestring = (char*)output;\n"
"\n"
"    input_buffer->offset = (size_t) (input_end - input_buffer->content);\n"
"    input_buffer->offset++;\n"
"\n"
"    return true;\n"
"\n"
"fail:\n"
"    if (output != NULL)\n"
"    {\n"
"        input_buffer->hooks.deallocate(output);\n"
"    }\n"
"\n"
"    if (input_pointer != NULL)\n"
"    {\n"
"        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);\n"
"    }\n"
"\n"
"    return false;\n"
"}\n"
"\n"
"/* Render the cstring provided to an escaped version that can be printed. */\n"
"static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)\n"
"{\n"
"    const unsigned char *input_pointer = NULL;\n"
"    unsigned char *output = NULL;\n"
"    unsigned char *output_pointer = NULL;\n"
"    size_t output_length = 0;\n"
"    /* numbers of additional characters needed for escaping */\n"
"    size_t escape_characters = 0;\n"
"\n"
"    if (output_buffer == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    /* empty string */\n"
"    if (input == NULL)\n"
"    {\n"
"        output = ensure(output_buffer, sizeof(\"\\\"\\\"\"));\n"
"        if (output == NULL)\n"
"        {\n"
"            return false;\n"
"        }\n"
"        strcpy((char*)output, \"\\\"\\\"\");\n"
"\n"
"        return true;\n"
"    }\n"
"\n"
"    /* set \"flag\" to 1 if something needs to be escaped */\n"
"    for (input_pointer = input; *input_pointer; input_pointer++)\n"
"    {\n"
"        switch (*input_pointer)\n"
"        {\n"
"            case '\\\"':\n"
"            case '\\\\':\n"
"            case '\\b':\n"
"            case '\\f':\n"
"            case '\\n':\n"
"            case '\\r':\n"
"            case '\\t':\n"
"                /* one character escape sequence */\n"
"                escape_characters++;\n"
"                break;\n"
"            default:\n"
"                if (*input_pointer < 32)\n"
"                {\n"
"                    /* UTF-16 escape sequence uXXXX */\n"
"                    escape_characters += 5;\n"
"                }\n"
"                break;\n"
"        }\n"
"    }\n"
"    output_length = (size_t)(input_pointer - input) + escape_characters;\n"
"\n"
"    output = ensure(output_buffer, output_length + sizeof(\"\\\"\\\"\"));\n"
"    if (output == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    /* no characters have to be escaped */\n"
"    if (escape_characters == 0)\n"
"    {\n"
"        output[0] = '\\\"';\n"
"        memcpy(output + 1, input, output_length);\n"
"        output[output_length + 1] = '\\\"';\n"
"        output[output_length + 2] = '\\0';\n"
"\n"
"        return true;\n"
"    }\n"
"\n"
"    output[0] = '\\\"';\n"
"    output_pointer = output + 1;\n"
"    /* copy the string */\n"
"    for (input_pointer = input; *input_pointer != '\\0'; (void)input_pointer++, output_pointer++)\n"
"    {\n"
"        if ((*input_pointer > 31) && (*input_pointer != '\\\"') && (*input_pointer != '\\\\'))\n"
"        {\n"
"            /* normal character, copy */\n"
"            *output_pointer = *input_pointer;\n"
"        }\n"
"        else\n"
"        {\n"
"            /* character needs to be escaped */\n"
"            *output_pointer++ = '\\\\';\n"
"            switch (*input_pointer)\n"
"            {\n"
"                case '\\\\':\n"
"                    *output_pointer = '\\\\';\n"
"                    break;\n"
"                case '\\\"':\n"
"                    *output_pointer = '\\\"';\n"
"                    break;\n"
"                case '\\b':\n"
"                    *output_pointer = 'b';\n"
"                    break;\n"
"                case '\\f':\n"
"                    *output_pointer = 'f';\n"
"                    break;\n"
"                case '\\n':\n"
"                    *output_pointer = 'n';\n"
"                    break;\n"
"                case '\\r':\n"
"                    *output_pointer = 'r';\n"
"                    break;\n"
"                case '\\t':\n"
"                    *output_pointer = 't';\n"
"                    break;\n"
"                default:\n"
"                    /* escape and print as unicode codepoint */\n"
"                    sprintf((char*)output_pointer, \"u%04x\", *input_pointer);\n"
"                    output_pointer += 4;\n"
"                    break;\n"
"            }\n"
"        }\n"
"    }\n"
"    output[output_length + 1] = '\\\"';\n"
"    output[output_length + 2] = '\\0';\n"
"\n"
"    return true;\n"
"}\n"
"\n"
"/* Invoke print_string_ptr (which is useful) on an item. */\n"
"static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)\n"
"{\n"
"    return print_string_ptr((unsigned char*)item->valuestring, p);\n"
"}\n"
"\n"
"/* Predeclare these prototypes. */\n"
"static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);\n"
"static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);\n"
"static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);\n"
"static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);\n"
"static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);\n"
"static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);\n"
"\n"
"/* Utility to jump whitespace and cr/lf */\n"
"static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)\n"
"{\n"
"    if ((buffer == NULL) || (buffer->content == NULL))\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))\n"
"    {\n"
"       buffer->offset++;\n"
"    }\n"
"\n"
"    if (buffer->offset == buffer->length)\n"
"    {\n"
"        buffer->offset--;\n"
"    }\n"
"\n"
"    return buffer;\n"
"}\n"
"\n"
"/* Parse an object - create a new root, and populate. */\n"
"CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)\n"
"{\n"
"    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n"
"    cJSON *item = NULL;\n"
"\n"
"    /* reset error position */\n"
"    global_error.json = NULL;\n"
"    global_error.position = 0;\n"
"\n"
"    if (value == NULL)\n"
"    {\n"
"        goto fail;\n"
"    }\n"
"\n"
"    buffer.content = (const unsigned char*)value;\n"
"    buffer.length = strlen((const char*)value) + sizeof(\"\");\n"
"    buffer.offset = 0;\n"
"    buffer.hooks = global_hooks;\n"
"\n"
"    item = cJSON_New_Item(&global_hooks);\n"
"    if (item == NULL) /* memory fail */\n"
"    {\n"
"        goto fail;\n"
"    }\n"
"\n"
"    if (!parse_value(item, buffer_skip_whitespace(&buffer)))\n"
"    {\n"
"        /* parse failure. ep is set. */\n"
"        goto fail;\n"
"    }\n"
"\n"
"    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n"
"    if (require_null_terminated)\n"
"    {\n"
"        buffer_skip_whitespace(&buffer);\n"
"        if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\\0')\n"
"        {\n"
"            goto fail;\n"
"        }\n"
"    }\n"
"    if (return_parse_end)\n"
"    {\n"
"        *return_parse_end = (const char*)buffer_at_offset(&buffer);\n"
"    }\n"
"\n"
"    return item;\n"
"\n"
"fail:\n"
"    if (item != NULL)\n"
"    {\n"
"        cJSON_Delete(item);\n"
"    }\n"
"\n"
"    if (value != NULL)\n"
"    {\n"
"        error local_error;\n"
"        local_error.json = (const unsigned char*)value;\n"
"        local_error.position = 0;\n"
"\n"
"        if (buffer.offset < buffer.length)\n"
"        {\n"
"            local_error.position = buffer.offset;\n"
"        }\n"
"        else if (buffer.length > 0)\n"
"        {\n"
"            local_error.position = buffer.length - 1;\n"
"        }\n"
"\n"
"        if (return_parse_end != NULL)\n"
"        {\n"
"            *return_parse_end = (const char*)local_error.json + local_error.position;\n"
"        }\n"
" \n"
"        global_error = local_error;\n"
"    }\n"
"\n"
"    return NULL;\n"
"}\n"
"\n"
"/* Default options for cJSON_Parse */\n"
"CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)\n"
"{\n"
"    return cJSON_ParseWithOpts(value, 0, 0);\n"
"}\n"
"\n"
"#define cjson_min(a, b) ((a < b) ? a : b)\n"
"\n"
"static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)\n"
"{\n"
"    printbuffer buffer[1];\n"
"    unsigned char *printed = NULL;\n"
"\n"
"    memset(buffer, 0, sizeof(buffer));\n"
"\n"
"    /* create buffer */\n"
"    buffer->buffer = (unsigned char*) hooks->allocate(256);\n"
"    buffer->format = format;\n"
"    buffer->hooks = *hooks;\n"
"    if (buffer->buffer == NULL)\n"
"    {\n"
"        goto fail;\n"
"    }\n"
"\n"
"    /* print the value */\n"
"    if (!print_value(item, buffer))\n"
"    {\n"
"        goto fail;\n"
"    }\n"
"    update_offset(buffer);\n"
"\n"
"    /* check if reallocate is available */\n"
"    if (hooks->reallocate != NULL)\n"
"    {\n"
"        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->length);\n"
"        buffer->buffer = NULL;\n"
"        if (printed == NULL) {\n"
"            goto fail;\n"
"        }\n"
"    }\n"
"    else /* otherwise copy the JSON over to a new buffer */\n"
"    {\n"
"        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);\n"
"        if (printed == NULL)\n"
"        {\n"
"            goto fail;\n"
"        }\n"
"        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));\n"
"        printed[buffer->offset] = '\\0'; /* just to be sure */\n"
"\n"
"        /* free the buffer */\n"
"        hooks->deallocate(buffer->buffer);\n"
"    }\n"
"\n"
"    return printed;\n"
"\n"
"fail:\n"
"    if (buffer->buffer != NULL)\n"
"    {\n"
"        hooks->deallocate(buffer->buffer);\n"
"    }\n"
"\n"
"    if (printed != NULL)\n"
"    {\n"
"        hooks->deallocate(printed);\n"
"    }\n"
"\n"
"    return NULL;\n"
"}\n"
"\n"
"/* Render a cJSON item/entity/structure to text. */\n"
"CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)\n"
"{\n"
"    return (char*)print(item, true, &global_hooks);\n"
"}\n"
"\n"
"CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)\n"
"{\n"
"    return (char*)print(item, false, &global_hooks);\n"
"}\n"
"\n"
"CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)\n"
"{\n"
"    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n"
"\n"
"    if (prebuffer < 0)\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);\n"
"    if (!p.buffer)\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    p.length = (size_t)prebuffer;\n"
"    p.offset = 0;\n"
"    p.noalloc = false;\n"
"    p.format = fmt;\n"
"    p.hooks = global_hooks;\n"
"\n"
"    if (!print_value(item, &p))\n"
"    {\n"
"        global_hooks.deallocate(p.buffer);\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return (char*)p.buffer;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cJSON_bool fmt)\n"
"{\n"
"    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n"
"\n"
"    if ((len < 0) || (buf == NULL))\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    p.buffer = (unsigned char*)buf;\n"
"    p.length = (size_t)len;\n"
"    p.offset = 0;\n"
"    p.noalloc = true;\n"
"    p.format = fmt;\n"
"    p.hooks = global_hooks;\n"
"\n"
"    return print_value(item, &p);\n"
"}\n"
"\n"
"/* Parser core - when encountering text, process appropriately. */\n"
"static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)\n"
"{\n"
"    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n"
"    {\n"
"        return false; /* no input */\n"
"    }\n"
"\n"
"    /* parse the different types of values */\n"
"    /* null */\n"
"    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"null\", 4) == 0))\n"
"    {\n"
"        item->type = cJSON_NULL;\n"
"        input_buffer->offset += 4;\n"
"        return true;\n"
"    }\n"
"    /* false */\n"
"    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), \"false\", 5) == 0))\n"
"    {\n"
"        item->type = cJSON_False;\n"
"        input_buffer->offset += 5;\n"
"        return true;\n"
"    }\n"
"    /* true */\n"
"    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"true\", 4) == 0))\n"
"    {\n"
"        item->type = cJSON_True;\n"
"        item->valueint = 1;\n"
"        input_buffer->offset += 4;\n"
"        return true;\n"
"    }\n"
"    /* string */\n"
"    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\\\"'))\n"
"    {\n"
"        return parse_string(item, input_buffer);\n"
"    }\n"
"    /* number */\n"
"    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))\n"
"    {\n"
"        return parse_number(item, input_buffer);\n"
"    }\n"
"    /* array */\n"
"    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))\n"
"    {\n"
"        return parse_array(item, input_buffer);\n"
"    }\n"
"    /* object */\n"
"    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))\n"
"    {\n"
"        return parse_object(item, input_buffer);\n"
"    }\n"
"\n"
"\n"
"    return false;\n"
"}\n"
"\n"
"/* Render a value to text. */\n"
"static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)\n"
"{\n"
"    unsigned char *output = NULL;\n"
"\n"
"    if ((item == NULL) || (output_buffer == NULL))\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    switch ((item->type) & 0xFF)\n"
"    {\n"
"        case cJSON_NULL:\n"
"            output = ensure(output_buffer, 5);\n"
"            if (output == NULL)\n"
"            {\n"
"                return false;\n"
"            }\n"
"            strcpy((char*)output, \"null\");\n"
"            return true;\n"
"\n"
"        case cJSON_False:\n"
"            output = ensure(output_buffer, 6);\n"
"            if (output == NULL)\n"
"            {\n"
"                return false;\n"
"            }\n"
"            strcpy((char*)output, \"false\");\n"
"            return true;\n"
"\n"
"        case cJSON_True:\n"
"            output = ensure(output_buffer, 5);\n"
"            if (output == NULL)\n"
"            {\n"
"                return false;\n"
"            }\n"
"            strcpy((char*)output, \"true\");\n"
"            return true;\n"
"\n"
"        case cJSON_Number:\n"
"            return print_number(item, output_buffer);\n"
"\n"
"        case cJSON_Raw:\n"
"        {\n"
"            size_t raw_length = 0;\n"
"            if (item->valuestring == NULL)\n"
"            {\n"
"                if (!output_buffer->noalloc)\n"
"                {\n"
"                    output_buffer->hooks.deallocate(output_buffer->buffer);\n"
"                }\n"
"                return false;\n"
"            }\n"
"\n"
"            raw_length = strlen(item->valuestring) + sizeof(\"\");\n"
"            output = ensure(output_buffer, raw_length);\n"
"            if (output == NULL)\n"
"            {\n"
"                return false;\n"
"            }\n"
"            memcpy(output, item->valuestring, raw_length);\n"
"            return true;\n"
"        }\n"
"\n"
"        case cJSON_String:\n"
"            return print_string(item, output_buffer);\n"
"\n"
"        case cJSON_Array:\n"
"            return print_array(item, output_buffer);\n"
"\n"
"        case cJSON_Object:\n"
"            return print_object(item, output_buffer);\n"
"\n"
"        default:\n"
"            return false;\n"
"    }\n"
"}\n"
"\n"
"/* Build an array from input text. */\n"
"static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)\n"
"{\n"
"    cJSON *head = NULL; /* head of the linked list */\n"
"    cJSON *current_item = NULL;\n"
"\n"
"    if (input_buffer->depth >= CJSON_NESTING_LIMIT)\n"
"    {\n"
"        return false; /* to deeply nested */\n"
"    }\n"
"    input_buffer->depth++;\n"
"\n"
"    if (buffer_at_offset(input_buffer)[0] != '[')\n"
"    {\n"
"        /* not an array */\n"
"        goto fail;\n"
"    }\n"
"\n"
"    input_buffer->offset++;\n"
"    buffer_skip_whitespace(input_buffer);\n"
"    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))\n"
"    {\n"
"        /* empty array */\n"
"        goto success;\n"
"    }\n"
"\n"
"    /* check if we skipped to the end of the buffer */\n"
"    if (cannot_access_at_index(input_buffer, 0))\n"
"    {\n"
"        input_buffer->offset--;\n"
"        goto fail;\n"
"    }\n"
"\n"
"    /* step back to character in front of the first element */\n"
"    input_buffer->offset--;\n"
"    /* loop through the comma separated array elements */\n"
"    do\n"
"    {\n"
"        /* allocate next item */\n"
"        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));\n"
"        if (new_item == NULL)\n"
"        {\n"
"            goto fail; /* allocation failure */\n"
"        }\n"
"\n"
"        /* attach next item to list */\n"
"        if (head == NULL)\n"
"        {\n"
"            /* start the linked list */\n"
"            current_item = head = new_item;\n"
"        }\n"
"        else\n"
"        {\n"
"            /* add to the end and advance */\n"
"            current_item->next = new_item;\n"
"            new_item->prev = current_item;\n"
"            current_item = new_item;\n"
"        }\n"
"\n"
"        /* parse next value */\n"
"        input_buffer->offset++;\n"
"        buffer_skip_whitespace(input_buffer);\n"
"        if (!parse_value(current_item, input_buffer))\n"
"        {\n"
"            goto fail; /* failed to parse value */\n"
"        }\n"
"        buffer_skip_whitespace(input_buffer);\n"
"    }\n"
"    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));\n"
"\n"
"    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')\n"
"    {\n"
"        goto fail; /* expected end of array */\n"
"    }\n"
"\n"
"success:\n"
"    input_buffer->depth--;\n"
"\n"
"    item->type = cJSON_Array;\n"
"    item->child = head;\n"
"\n"
"    input_buffer->offset++;\n"
"\n"
"    return true;\n"
"\n"
"fail:\n"
"    if (head != NULL)\n"
"    {\n"
"        cJSON_Delete(head);\n"
"    }\n"
"\n"
"    return false;\n"
"}\n"
"\n"
"/* Render an array to text */\n"
"static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)\n"
"{\n"
"    unsigned char *output_pointer = NULL;\n"
"    size_t length = 0;\n"
"    cJSON *current_element = item->child;\n"
"\n"
"    if (output_buffer == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    /* Compose the output array. */\n"
"    /* opening square bracket */\n"
"    output_pointer = ensure(output_buffer, 1);\n"
"    if (output_pointer == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    *output_pointer = '[';\n"
"    output_buffer->offset++;\n"
"    output_buffer->depth++;\n"
"\n"
"    while (current_element != NULL)\n"
"    {\n"
"        if (!print_value(current_element, output_buffer))\n"
"        {\n"
"            return false;\n"
"        }\n"
"        update_offset(output_buffer);\n"
"        if (current_element->next)\n"
"        {\n"
"            length = (size_t) (output_buffer->format ? 2 : 1);\n"
"            output_pointer = ensure(output_buffer, length + 1);\n"
"            if (output_pointer == NULL)\n"
"            {\n"
"                return false;\n"
"            }\n"
"            *output_pointer++ = ',';\n"
"            if(output_buffer->format)\n"
"            {\n"
"                *output_pointer++ = ' ';\n"
"            }\n"
"            *output_pointer = '\\0';\n"
"            output_buffer->offset += length;\n"
"        }\n"
"        current_element = current_element->next;\n"
"    }\n"
"\n"
"    output_pointer = ensure(output_buffer, 2);\n"
"    if (output_pointer == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"    *output_pointer++ = ']';\n"
"    *output_pointer = '\\0';\n"
"    output_buffer->depth--;\n"
"\n"
"    return true;\n"
"}\n"
"\n"
"/* Build an object from the text. */\n"
"static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)\n"
"{\n"
"    cJSON *head = NULL; /* linked list head */\n"
"    cJSON *current_item = NULL;\n"
"\n"
"    if (input_buffer->depth >= CJSON_NESTING_LIMIT)\n"
"    {\n"
"        return false; /* to deeply nested */\n"
"    }\n"
"    input_buffer->depth++;\n"
"\n"
"    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))\n"
"    {\n"
"        goto fail; /* not an object */\n"
"    }\n"
"\n"
"    input_buffer->offset++;\n"
"    buffer_skip_whitespace(input_buffer);\n"
"    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))\n"
"    {\n"
"        goto success; /* empty object */\n"
"    }\n"
"\n"
"    /* check if we skipped to the end of the buffer */\n"
"    if (cannot_access_at_index(input_buffer, 0))\n"
"    {\n"
"        input_buffer->offset--;\n"
"        goto fail;\n"
"    }\n"
"\n"
"    /* step back to character in front of the first element */\n"
"    input_buffer->offset--;\n"
"    /* loop through the comma separated array elements */\n"
"    do\n"
"    {\n"
"        /* allocate next item */\n"
"        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));\n"
"        if (new_item == NULL)\n"
"        {\n"
"            goto fail; /* allocation failure */\n"
"        }\n"
"\n"
"        /* attach next item to list */\n"
"        if (head == NULL)\n"
"        {\n"
"            /* start the linked list */\n"
"            current_item = head = new_item;\n"
"        }\n"
"        else\n"
"        {\n"
"            /* add to the end and advance */\n"
"            current_item->next = new_item;\n"
"            new_item->prev = current_item;\n"
"            current_item = new_item;\n"
"        }\n"
"\n"
"        /* parse the name of the child */\n"
"        input_buffer->offset++;\n"
"        buffer_skip_whitespace(input_buffer);\n"
"        if (!parse_string(current_item, input_buffer))\n"
"        {\n"
"            goto fail; /* faile to parse name */\n"
"        }\n"
"        buffer_skip_whitespace(input_buffer);\n"
"\n"
"        /* swap valuestring and string, because we parsed the name */\n"
"        current_item->string = current_item->valuestring;\n"
"        current_item->valuestring = NULL;\n"
"\n"
"        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))\n"
"        {\n"
"            goto fail; /* invalid object */\n"
"        }\n"
"\n"
"        /* parse the value */\n"
"        input_buffer->offset++;\n"
"        buffer_skip_whitespace(input_buffer);\n"
"        if (!parse_value(current_item, input_buffer))\n"
"        {\n"
"            goto fail; /* failed to parse value */\n"
"        }\n"
"        buffer_skip_whitespace(input_buffer);\n"
"    }\n"
"    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));\n"
"\n"
"    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))\n"
"    {\n"
"        goto fail; /* expected end of object */\n"
"    }\n"
"\n"
"success:\n"
"    input_buffer->depth--;\n"
"\n"
"    item->type = cJSON_Object;\n"
"    item->child = head;\n"
"\n"
"    input_buffer->offset++;\n"
"    return true;\n"
"\n"
"fail:\n"
"    if (head != NULL)\n"
"    {\n"
"        cJSON_Delete(head);\n"
"    }\n"
"\n"
"    return false;\n"
"}\n"
"\n"
"/* Render an object to text. */\n"
"static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)\n"
"{\n"
"    unsigned char *output_pointer = NULL;\n"
"    size_t length = 0;\n"
"    cJSON *current_item = item->child;\n"
"\n"
"    if (output_buffer == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    /* Compose the output: */\n"
"    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\\n */\n"
"    output_pointer = ensure(output_buffer, length + 1);\n"
"    if (output_pointer == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    *output_pointer++ = '{';\n"
"    output_buffer->depth++;\n"
"    if (output_buffer->format)\n"
"    {\n"
"        *output_pointer++ = '\\n';\n"
"    }\n"
"    output_buffer->offset += length;\n"
"\n"
"    while (current_item)\n"
"    {\n"
"        if (output_buffer->format)\n"
"        {\n"
"            size_t i;\n"
"            output_pointer = ensure(output_buffer, output_buffer->depth);\n"
"            if (output_pointer == NULL)\n"
"            {\n"
"                return false;\n"
"            }\n"
"            for (i = 0; i < output_buffer->depth; i++)\n"
"            {\n"
"                *output_pointer++ = '\\t';\n"
"            }\n"
"            output_buffer->offset += output_buffer->depth;\n"
"        }\n"
"\n"
"        /* print key */\n"
"        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))\n"
"        {\n"
"            return false;\n"
"        }\n"
"        update_offset(output_buffer);\n"
"\n"
"        length = (size_t) (output_buffer->format ? 2 : 1);\n"
"        output_pointer = ensure(output_buffer, length);\n"
"        if (output_pointer == NULL)\n"
"        {\n"
"            return false;\n"
"        }\n"
"        *output_pointer++ = ':';\n"
"        if (output_buffer->format)\n"
"        {\n"
"            *output_pointer++ = '\\t';\n"
"        }\n"
"        output_buffer->offset += length;\n"
"\n"
"        /* print value */\n"
"        if (!print_value(current_item, output_buffer))\n"
"        {\n"
"            return false;\n"
"        }\n"
"        update_offset(output_buffer);\n"
"\n"
"        /* print comma if not last */\n"
"        length = (size_t) ((output_buffer->format ? 1 : 0) + (current_item->next ? 1 : 0));\n"
"        output_pointer = ensure(output_buffer, length + 1);\n"
"        if (output_pointer == NULL)\n"
"        {\n"
"            return false;\n"
"        }\n"
"        if (current_item->next)\n"
"        {\n"
"            *output_pointer++ = ',';\n"
"        }\n"
"\n"
"        if (output_buffer->format)\n"
"        {\n"
"            *output_pointer++ = '\\n';\n"
"        }\n"
"        *output_pointer = '\\0';\n"
"        output_buffer->offset += length;\n"
"\n"
"        current_item = current_item->next;\n"
"    }\n"
"\n"
"    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);\n"
"    if (output_pointer == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"    if (output_buffer->format)\n"
"    {\n"
"        size_t i;\n"
"        for (i = 0; i < (output_buffer->depth - 1); i++)\n"
"        {\n"
"            *output_pointer++ = '\\t';\n"
"        }\n"
"    }\n"
"    *output_pointer++ = '}';\n"
"    *output_pointer = '\\0';\n"
"    output_buffer->depth--;\n"
"\n"
"    return true;\n"
"}\n"
"\n"
"/* Get Array size/item / object item. */\n"
"CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)\n"
"{\n"
"    cJSON *child = NULL;\n"
"    size_t size = 0;\n"
"\n"
"    if (array == NULL)\n"
"    {\n"
"        return 0;\n"
"    }\n"
"\n"
"    child = array->child;\n"
"\n"
"    while(child != NULL)\n"
"    {\n"
"        size++;\n"
"        child = child->next;\n"
"    }\n"
"\n"
"    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */\n"
"\n"
"    return (int)size;\n"
"}\n"
"\n"
"static cJSON* get_array_item(const cJSON *array, size_t index)\n"
"{\n"
"    cJSON *current_child = NULL;\n"
"\n"
"    if (array == NULL)\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    current_child = array->child;\n"
"    while ((current_child != NULL) && (index > 0))\n"
"    {\n"
"        index--;\n"
"        current_child = current_child->next;\n"
"    }\n"
"\n"
"    return current_child;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)\n"
"{\n"
"    if (index < 0)\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return get_array_item(array, (size_t)index);\n"
"}\n"
"\n"
"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n"
"{\n"
"    cJSON *current_element = NULL;\n"
"\n"
"    if ((object == NULL) || (name == NULL))\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    current_element = object->child;\n"
"    if (case_sensitive)\n"
"    {\n"
"        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n"
"        {\n"
"            current_element = current_element->next;\n"
"        }\n"
"    }\n"
"    else\n"
"    {\n"
"        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n"
"        {\n"
"            current_element = current_element->next;\n"
"        }\n"
"    }\n"
"\n"
"    return current_element;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)\n"
"{\n"
"    return get_object_item(object, string, false);\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)\n"
"{\n"
"    return get_object_item(object, string, true);\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)\n"
"{\n"
"    return cJSON_GetObjectItem(object, string) ? 1 : 0;\n"
"}\n"
"\n"
"/* Utility for array list handling. */\n"
"static void suffix_object(cJSON *prev, cJSON *item)\n"
"{\n"
"    prev->next = item;\n"
"    item->prev = prev;\n"
"}\n"
"\n"
"/* Utility for handling references. */\n"
"static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)\n"
"{\n"
"    cJSON *reference = NULL;\n"
"    if (item == NULL)\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    reference = cJSON_New_Item(hooks);\n"
"    if (reference == NULL)\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    memcpy(reference, item, sizeof(cJSON));\n"
"    reference->string = NULL;\n"
"    reference->type |= cJSON_IsReference;\n"
"    reference->next = reference->prev = NULL;\n"
"    return reference;\n"
"}\n"
"\n"
"/* Add item to array/object. */\n"
"CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)\n"
"{\n"
"    cJSON *child = NULL;\n"
"\n"
"    if ((item == NULL) || (array == NULL))\n"
"    {\n"
"        return;\n"
"    }\n"
"\n"
"    child = array->child;\n"
"\n"
"    if (child == NULL)\n"
"    {\n"
"        /* list is empty, start new one */\n"
"        array->child = item;\n"
"    }\n"
"    else\n"
"    {\n"
"        /* append to the end */\n"
"        while (child->next)\n"
"        {\n"
"            child = child->next;\n"
"        }\n"
"        suffix_object(child, item);\n"
"    }\n"
"}\n"
"\n"
"CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)\n"
"{\n"
"    if (item == NULL)\n"
"    {\n"
"        return;\n"
"    }\n"
"\n"
"    /* call cJSON_AddItemToObjectCS for code reuse */\n"
"    cJSON_AddItemToObjectCS(object, (char*)cJSON_strdup((const unsigned char*)string, &global_hooks), item);\n"
"    /* remove cJSON_StringIsConst flag */\n"
"    item->type &= ~cJSON_StringIsConst;\n"
"}\n"
"\n"
"#if defined (__clang__) || ((__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))\n"
"    #pragma GCC diagnostic push\n"
"#endif\n"
"#ifdef __GNUC__\n"
"#pragma GCC diagnostic ignored \"-Wcast-qual\"\n"
"#endif\n"
"\n"
"/* Add an item to an object with constant string as key */\n"
"CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)\n"
"{\n"
"    if ((item == NULL) || (string == NULL))\n"
"    {\n"
"        return;\n"
"    }\n"
"    if (!(item->type & cJSON_StringIsConst) && item->string)\n"
"    {\n"
"        global_hooks.deallocate(item->string);\n"
"    }\n"
"    item->string = (char*)string;\n"
"    item->type |= cJSON_StringIsConst;\n"
"    cJSON_AddItemToArray(object, item);\n"
"}\n"
"#if defined (__clang__) || ((__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))\n"
"    #pragma GCC diagnostic pop\n"
"#endif\n"
"\n"
"CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\n"
"{\n"
"    if (array == NULL)\n"
"    {\n"
"        return;\n"
"    }\n"
"\n"
"    cJSON_AddItemToArray(array, create_reference(item, &global_hooks));\n"
"}\n"
"\n"
"CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)\n"
"{\n"
"    if ((object == NULL) || (string == NULL))\n"
"    {\n"
"        return;\n"
"    }\n"
"\n"
"    cJSON_AddItemToObject(object, string, create_reference(item, &global_hooks));\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)\n"
"{\n"
"    if ((parent == NULL) || (item == NULL))\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    if (item->prev != NULL)\n"
"    {\n"
"        /* not the first element */\n"
"        item->prev->next = item->next;\n"
"    }\n"
"    if (item->next != NULL)\n"
"    {\n"
"        /* not the last element */\n"
"        item->next->prev = item->prev;\n"
"    }\n"
"\n"
"    if (item == parent->child)\n"
"    {\n"
"        /* first element */\n"
"        parent->child = item->next;\n"
"    }\n"
"    /* make sure the detached item doesn't point anywhere anymore */\n"
"    item->prev = NULL;\n"
"    item->next = NULL;\n"
"\n"
"    return item;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)\n"
"{\n"
"    if (which < 0)\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));\n"
"}\n"
"\n"
"CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)\n"
"{\n"
"    cJSON_Delete(cJSON_DetachItemFromArray(array, which));\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)\n"
"{\n"
"    cJSON *to_detach = cJSON_GetObjectItem(object, string);\n"
"\n"
"    return cJSON_DetachItemViaPointer(object, to_detach);\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)\n"
"{\n"
"    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);\n"
"\n"
"    return cJSON_DetachItemViaPointer(object, to_detach);\n"
"}\n"
"\n"
"CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)\n"
"{\n"
"    cJSON_Delete(cJSON_DetachItemFromObject(object, string));\n"
"}\n"
"\n"
"CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)\n"
"{\n"
"    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));\n"
"}\n"
"\n"
"/* Replace array/object items with new ones. */\n"
"CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)\n"
"{\n"
"    cJSON *after_inserted = NULL;\n"
"\n"
"    if (which < 0)\n"
"    {\n"
"        return;\n"
"    }\n"
"\n"
"    after_inserted = get_array_item(array, (size_t)which);\n"
"    if (after_inserted == NULL)\n"
"    {\n"
"        cJSON_AddItemToArray(array, newitem);\n"
"        return;\n"
"    }\n"
"\n"
"    newitem->next = after_inserted;\n"
"    newitem->prev = after_inserted->prev;\n"
"    after_inserted->prev = newitem;\n"
"    if (after_inserted == array->child)\n"
"    {\n"
"        array->child = newitem;\n"
"    }\n"
"    else\n"
"    {\n"
"        newitem->prev->next = newitem;\n"
"    }\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)\n"
"{\n"
"    if ((parent == NULL) || (replacement == NULL) || (item == NULL))\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    if (replacement == item)\n"
"    {\n"
"        return true;\n"
"    }\n"
"\n"
"    replacement->next = item->next;\n"
"    replacement->prev = item->prev;\n"
"\n"
"    if (replacement->next != NULL)\n"
"    {\n"
"        replacement->next->prev = replacement;\n"
"    }\n"
"    if (replacement->prev != NULL)\n"
"    {\n"
"        replacement->prev->next = replacement;\n"
"    }\n"
"    if (parent->child == item)\n"
"    {\n"
"        parent->child = replacement;\n"
"    }\n"
"\n"
"    item->next = NULL;\n"
"    item->prev = NULL;\n"
"    cJSON_Delete(item);\n"
"\n"
"    return true;\n"
"}\n"
"\n"
"CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)\n"
"{\n"
"    if (which < 0)\n"
"    {\n"
"        return;\n"
"    }\n"
"\n"
"    cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);\n"
"}\n"
"\n"
"static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)\n"
"{\n"
"    if ((replacement == NULL) || (string == NULL))\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    /* replace the name in the replacement */\n"
"    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))\n"
"    {\n"
"        cJSON_free(replacement->string);\n"
"    }\n"
"    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);\n"
"    replacement->type &= ~cJSON_StringIsConst;\n"
"\n"
"    cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);\n"
"\n"
"    return true;\n"
"}\n"
"\n"
"CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)\n"
"{\n"
"    replace_item_in_object(object, string, newitem, false);\n"
"}\n"
"\n"
"CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)\n"
"{\n"
"    replace_item_in_object(object, string, newitem, true);\n"
"}\n"
"\n"
"/* Create basic types: */\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)\n"
"{\n"
"    cJSON *item = cJSON_New_Item(&global_hooks);\n"
"    if(item)\n"
"    {\n"
"        item->type = cJSON_NULL;\n"
"    }\n"
"\n"
"    return item;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)\n"
"{\n"
"    cJSON *item = cJSON_New_Item(&global_hooks);\n"
"    if(item)\n"
"    {\n"
"        item->type = cJSON_True;\n"
"    }\n"
"\n"
"    return item;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)\n"
"{\n"
"    cJSON *item = cJSON_New_Item(&global_hooks);\n"
"    if(item)\n"
"    {\n"
"        item->type = cJSON_False;\n"
"    }\n"
"\n"
"    return item;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool b)\n"
"{\n"
"    cJSON *item = cJSON_New_Item(&global_hooks);\n"
"    if(item)\n"
"    {\n"
"        item->type = b ? cJSON_True : cJSON_False;\n"
"    }\n"
"\n"
"    return item;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)\n"
"{\n"
"    cJSON *item = cJSON_New_Item(&global_hooks);\n"
"    if(item)\n"
"    {\n"
"        item->type = cJSON_Number;\n"
"        item->valuedouble = num;\n"
"\n"
"        /* use saturation in case of overflow */\n"
"        if (num >= INT_MAX)\n"
"        {\n"
"            item->valueint = INT_MAX;\n"
"        }\n"
"        else if (num <= INT_MIN)\n"
"        {\n"
"            item->valueint = INT_MIN;\n"
"        }\n"
"        else\n"
"        {\n"
"            item->valueint = (int)num;\n"
"        }\n"
"    }\n"
"\n"
"    return item;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)\n"
"{\n"
"    cJSON *item = cJSON_New_Item(&global_hooks);\n"
"    if(item)\n"
"    {\n"
"        item->type = cJSON_String;\n"
"        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);\n"
"        if(!item->valuestring)\n"
"        {\n"
"            cJSON_Delete(item);\n"
"            return NULL;\n"
"        }\n"
"    }\n"
"\n"
"    return item;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)\n"
"{\n"
"    cJSON *item = cJSON_New_Item(&global_hooks);\n"
"    if(item)\n"
"    {\n"
"        item->type = cJSON_Raw;\n"
"        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);\n"
"        if(!item->valuestring)\n"
"        {\n"
"            cJSON_Delete(item);\n"
"            return NULL;\n"
"        }\n"
"    }\n"
"\n"
"    return item;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)\n"
"{\n"
"    cJSON *item = cJSON_New_Item(&global_hooks);\n"
"    if(item)\n"
"    {\n"
"        item->type=cJSON_Array;\n"
"    }\n"
"\n"
"    return item;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)\n"
"{\n"
"    cJSON *item = cJSON_New_Item(&global_hooks);\n"
"    if (item)\n"
"    {\n"
"        item->type = cJSON_Object;\n"
"    }\n"
"\n"
"    return item;\n"
"}\n"
"\n"
"/* Create Arrays: */\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)\n"
"{\n"
"    size_t i = 0;\n"
"    cJSON *n = NULL;\n"
"    cJSON *p = NULL;\n"
"    cJSON *a = NULL;\n"
"\n"
"    if ((count < 0) || (numbers == NULL))\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    a = cJSON_CreateArray();\n"
"    for(i = 0; a && (i < (size_t)count); i++)\n"
"    {\n"
"        n = cJSON_CreateNumber(numbers[i]);\n"
"        if (!n)\n"
"        {\n"
"            cJSON_Delete(a);\n"
"            return NULL;\n"
"        }\n"
"        if(!i)\n"
"        {\n"
"            a->child = n;\n"
"        }\n"
"        else\n"
"        {\n"
"            suffix_object(p, n);\n"
"        }\n"
"        p = n;\n"
"    }\n"
"\n"
"    return a;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)\n"
"{\n"
"    size_t i = 0;\n"
"    cJSON *n = NULL;\n"
"    cJSON *p = NULL;\n"
"    cJSON *a = NULL;\n"
"\n"
"    if ((count < 0) || (numbers == NULL))\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    a = cJSON_CreateArray();\n"
"\n"
"    for(i = 0; a && (i < (size_t)count); i++)\n"
"    {\n"
"        n = cJSON_CreateNumber((double)numbers[i]);\n"
"        if(!n)\n"
"        {\n"
"            cJSON_Delete(a);\n"
"            return NULL;\n"
"        }\n"
"        if(!i)\n"
"        {\n"
"            a->child = n;\n"
"        }\n"
"        else\n"
"        {\n"
"            suffix_object(p, n);\n"
"        }\n"
"        p = n;\n"
"    }\n"
"\n"
"    return a;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)\n"
"{\n"
"    size_t i = 0;\n"
"    cJSON *n = NULL;\n"
"    cJSON *p = NULL;\n"
"    cJSON *a = NULL;\n"
"\n"
"    if ((count < 0) || (numbers == NULL))\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    a = cJSON_CreateArray();\n"
"\n"
"    for(i = 0;a && (i < (size_t)count); i++)\n"
"    {\n"
"        n = cJSON_CreateNumber(numbers[i]);\n"
"        if(!n)\n"
"        {\n"
"            cJSON_Delete(a);\n"
"            return NULL;\n"
"        }\n"
"        if(!i)\n"
"        {\n"
"            a->child = n;\n"
"        }\n"
"        else\n"
"        {\n"
"            suffix_object(p, n);\n"
"        }\n"
"        p = n;\n"
"    }\n"
"\n"
"    return a;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count)\n"
"{\n"
"    size_t i = 0;\n"
"    cJSON *n = NULL;\n"
"    cJSON *p = NULL;\n"
"    cJSON *a = NULL;\n"
"\n"
"    if ((count < 0) || (strings == NULL))\n"
"    {\n"
"        return NULL;\n"
"    }\n"
"\n"
"    a = cJSON_CreateArray();\n"
"\n"
"    for (i = 0; a && (i < (size_t)count); i++)\n"
"    {\n"
"        n = cJSON_CreateString(strings[i]);\n"
"        if(!n)\n"
"        {\n"
"            cJSON_Delete(a);\n"
"            return NULL;\n"
"        }\n"
"        if(!i)\n"
"        {\n"
"            a->child = n;\n"
"        }\n"
"        else\n"
"        {\n"
"            suffix_object(p,n);\n"
"        }\n"
"        p = n;\n"
"    }\n"
"\n"
"    return a;\n"
"}\n"
"\n"
"/* Duplication */\n"
"CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)\n"
"{\n"
"    cJSON *newitem = NULL;\n"
"    cJSON *child = NULL;\n"
"    cJSON *next = NULL;\n"
"    cJSON *newchild = NULL;\n"
"\n"
"    /* Bail on bad ptr */\n"
"    if (!item)\n"
"    {\n"
"        goto fail;\n"
"    }\n"
"    /* Create new item */\n"
"    newitem = cJSON_New_Item(&global_hooks);\n"
"    if (!newitem)\n"
"    {\n"
"        goto fail;\n"
"    }\n"
"    /* Copy over all vars */\n"
"    newitem->type = item->type & (~cJSON_IsReference);\n"
"    newitem->valueint = item->valueint;\n"
"    newitem->valuedouble = item->valuedouble;\n"
"    if (item->valuestring)\n"
"    {\n"
"        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);\n"
"        if (!newitem->valuestring)\n"
"        {\n"
"            goto fail;\n"
"        }\n"
"    }\n"
"    if (item->string)\n"
"    {\n"
"        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);\n"
"        if (!newitem->string)\n"
"        {\n"
"            goto fail;\n"
"        }\n"
"    }\n"
"    /* If non-recursive, then we're done! */\n"
"    if (!recurse)\n"
"    {\n"
"        return newitem;\n"
"    }\n"
"    /* Walk the ->next chain for the child. */\n"
"    child = item->child;\n"
"    while (child != NULL)\n"
"    {\n"
"        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */\n"
"        if (!newchild)\n"
"        {\n"
"            goto fail;\n"
"        }\n"
"        if (next != NULL)\n"
"        {\n"
"            /* If newitem->child already set, then crosswire ->prev and ->next and move on */\n"
"            next->next = newchild;\n"
"            newchild->prev = next;\n"
"            next = newchild;\n"
"        }\n"
"        else\n"
"        {\n"
"            /* Set newitem->child and move to it */\n"
"            newitem->child = newchild;\n"
"            next = newchild;\n"
"        }\n"
"        child = child->next;\n"
"    }\n"
"\n"
"    return newitem;\n"
"\n"
"fail:\n"
"    if (newitem != NULL)\n"
"    {\n"
"        cJSON_Delete(newitem);\n"
"    }\n"
"\n"
"    return NULL;\n"
"}\n"
"\n"
"CJSON_PUBLIC(void) cJSON_Minify(char *json)\n"
"{\n"
"    unsigned char *into = (unsigned char*)json;\n"
"\n"
"    if (json == NULL)\n"
"    {\n"
"        return;\n"
"    }\n"
"\n"
"    while (*json)\n"
"    {\n"
"        if (*json == ' ')\n"
"        {\n"
"            json++;\n"
"        }\n"
"        else if (*json == '\\t')\n"
"        {\n"
"            /* Whitespace characters. */\n"
"            json++;\n"
"        }\n"
"        else if (*json == '\\r')\n"
"        {\n"
"            json++;\n"
"        }\n"
"        else if (*json=='\\n')\n"
"        {\n"
"            json++;\n"
"        }\n"
"        else if ((*json == '/') && (json[1] == '/'))\n"
"        {\n"
"            /* double-slash comments, to end of line. */\n"
"            while (*json && (*json != '\\n'))\n"
"            {\n"
"                json++;\n"
"            }\n"
"        }\n"
"        else if ((*json == '/') && (json[1] == '*'))\n"
"        {\n"
"            /* multiline comments. */\n"
"            while (*json && !((*json == '*') && (json[1] == '/')))\n"
"            {\n"
"                json++;\n"
"            }\n"
"            json += 2;\n"
"        }\n"
"        else if (*json == '\\\"')\n"
"        {\n"
"            /* string literals, which are \\\" sensitive. */\n"
"            *into++ = (unsigned char)*json++;\n"
"            while (*json && (*json != '\\\"'))\n"
"            {\n"
"                if (*json == '\\\\')\n"
"                {\n"
"                    *into++ = (unsigned char)*json++;\n"
"                }\n"
"                *into++ = (unsigned char)*json++;\n"
"            }\n"
"            *into++ = (unsigned char)*json++;\n"
"        }\n"
"        else\n"
"        {\n"
"            /* All other characters. */\n"
"            *into++ = (unsigned char)*json++;\n"
"        }\n"
"    }\n"
"\n"
"    /* and null-terminate. */\n"
"    *into = '\\0';\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)\n"
"{\n"
"    if (item == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    return (item->type & 0xFF) == cJSON_Invalid;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)\n"
"{\n"
"    if (item == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    return (item->type & 0xFF) == cJSON_False;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)\n"
"{\n"
"    if (item == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    return (item->type & 0xff) == cJSON_True;\n"
"}\n"
"\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)\n"
"{\n"
"    if (item == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    return (item->type & (cJSON_True | cJSON_False)) != 0;\n"
"}\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)\n"
"{\n"
"    if (item == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    return (item->type & 0xFF) == cJSON_NULL;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)\n"
"{\n"
"    if (item == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    return (item->type & 0xFF) == cJSON_Number;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)\n"
"{\n"
"    if (item == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    return (item->type & 0xFF) == cJSON_String;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)\n"
"{\n"
"    if (item == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    return (item->type & 0xFF) == cJSON_Array;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)\n"
"{\n"
"    if (item == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    return (item->type & 0xFF) == cJSON_Object;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)\n"
"{\n"
"    if (item == NULL)\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    return (item->type & 0xFF) == cJSON_Raw;\n"
"}\n"
"\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)\n"
"{\n"
"    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))\n"
"    {\n"
"        return false;\n"
"    }\n"
"\n"
"    /* check if type is valid */\n"
"    switch (a->type & 0xFF)\n"
"    {\n"
"        case cJSON_False:\n"
"        case cJSON_True:\n"
"        case cJSON_NULL:\n"
"        case cJSON_Number:\n"
"        case cJSON_String:\n"
"        case cJSON_Raw:\n"
"        case cJSON_Array:\n"
"        case cJSON_Object:\n"
"            break;\n"
"\n"
"        default:\n"
"            return false;\n"
"    }\n"
"\n"
"    /* identical objects are equal */\n"
"    if (a == b)\n"
"    {\n"
"        return true;\n"
"    }\n"
"\n"
"    switch (a->type & 0xFF)\n"
"    {\n"
"        /* in these cases and equal type is enough */\n"
"        case cJSON_False:\n"
"        case cJSON_True:\n"
"        case cJSON_NULL:\n"
"            return true;\n"
"\n"
"        case cJSON_Number:\n"
"            if (a->valuedouble == b->valuedouble)\n"
"            {\n"
"                return true;\n"
"            }\n"
"            return false;\n"
"\n"
"        case cJSON_String:\n"
"        case cJSON_Raw:\n"
"            if ((a->valuestring == NULL) || (b->valuestring == NULL))\n"
"            {\n"
"                return false;\n"
"            }\n"
"            if (strcmp(a->valuestring, b->valuestring) == 0)\n"
"            {\n"
"                return true;\n"
"            }\n"
"\n"
"            return false;\n"
"\n"
"        case cJSON_Array:\n"
"        {\n"
"            cJSON *a_element = a->child;\n"
"            cJSON *b_element = b->child;\n"
"\n"
"            for (; (a_element != NULL) && (b_element != NULL);)\n"
"            {\n"
"                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n"
"                {\n"
"                    return false;\n"
"                }\n"
"\n"
"                a_element = a_element->next;\n"
"                b_element = b_element->next;\n"
"            }\n"
"\n"
"            /* one of the arrays is longer than the other */\n"
"            if (a_element != b_element) {\n"
"                return false;\n"
"            }\n"
"\n"
"            return true;\n"
"        }\n"
"\n"
"        case cJSON_Object:\n"
"        {\n"
"            cJSON *a_element = NULL;\n"
"            cJSON *b_element = NULL;\n"
"            cJSON_ArrayForEach(a_element, a)\n"
"            {\n"
"                /* TODO This has O(n^2) runtime, which is horrible! */\n"
"                b_element = get_object_item(b, a_element->string, case_sensitive);\n"
"                if (b_element == NULL)\n"
"                {\n"
"                    return false;\n"
"                }\n"
"\n"
"                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n"
"                {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"\n"
"            /* doing this twice, once on a and b to prevent true comparison if a subset of b\n"
"             * TODO: Do this the proper way, this is just a fix for now */\n"
"            cJSON_ArrayForEach(b_element, b)\n"
"            {\n"
"                a_element = get_object_item(a, b_element->string, case_sensitive);\n"
"                if (a_element == NULL)\n"
"                {\n"
"                    return false;\n"
"                }\n"
"\n"
"                if (!cJSON_Compare(b_element, a_element, case_sensitive))\n"
"                {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"\n"
"            return true;\n"
"        }\n"
"\n"
"        default:\n"
"            return false;\n"
"    }\n"
"}\n"
"\n"
"CJSON_PUBLIC(void *) cJSON_malloc(size_t size)\n"
"{\n"
"    return global_hooks.allocate(size);\n"
"}\n"
"\n"
"CJSON_PUBLIC(void) cJSON_free(void *object)\n"
"{\n"
"    global_hooks.deallocate(object);\n"
"}\n";
