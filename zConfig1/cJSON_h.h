char *cJSON_h =
"/*\n"
"  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors\n"
"\n"
"  Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"  of this software and associated documentation files (the \"Software\"), to deal\n"
"  in the Software without restriction, including without limitation the rights\n"
"  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"  copies of the Software, and to permit persons to whom the Software is\n"
"  furnished to do so, subject to the following conditions:\n"
"\n"
"  The above copyright notice and this permission notice shall be included in\n"
"  all copies or substantial portions of the Software.\n"
"\n"
"  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
"  THE SOFTWARE.\n"
"*/\n"
"\n"
"#ifndef cJSON__h\n"
"#define cJSON__h\n"
"\n"
"#ifdef __cplusplus\n"
"extern \"C\"\n"
"{\n"
"#endif\n"
"\n"
"/* project version */\n"
"#define CJSON_VERSION_MAJOR 1\n"
"#define CJSON_VERSION_MINOR 5\n"
"#define CJSON_VERSION_PATCH 9\n"
"\n"
"#include <stddef.h>\n"
"\n"
"/* cJSON Types: */\n"
"#define cJSON_Invalid (0)\n"
"#define cJSON_False  (1 << 0)\n"
"#define cJSON_True   (1 << 1)\n"
"#define cJSON_NULL   (1 << 2)\n"
"#define cJSON_Number (1 << 3)\n"
"#define cJSON_String (1 << 4)\n"
"#define cJSON_Array  (1 << 5)\n"
"#define cJSON_Object (1 << 6)\n"
"#define cJSON_Raw    (1 << 7) /* raw json */\n"
"\n"
"#define cJSON_IsReference 256\n"
"#define cJSON_StringIsConst 512\n"
"\n"
"/* The cJSON structure: */\n"
"typedef struct cJSON\n"
"{\n"
"    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n"
"    struct cJSON *next;\n"
"    struct cJSON *prev;\n"
"    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n"
"    struct cJSON *child;\n"
"\n"
"    /* The type of the item, as above. */\n"
"    int type;\n"
"\n"
"    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */\n"
"    char *valuestring;\n"
"    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */\n"
"    int valueint;\n"
"    /* The item's number, if type==cJSON_Number */\n"
"    double valuedouble;\n"
"\n"
"    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n"
"    char *string;\n"
"} cJSON;\n"
"\n"
"typedef struct cJSON_Hooks\n"
"{\n"
"      void *(*malloc_fn)(size_t sz);\n"
"      void (*free_fn)(void *ptr);\n"
"} cJSON_Hooks;\n"
"\n"
"typedef int cJSON_bool;\n"
"\n"
"#if !defined(__WINDOWS__) && (defined(WIN32) || defined(WIN64) || defined(_MSC_VER) || defined(_WIN32))\n"
"#define __WINDOWS__\n"
"#endif\n"
"#ifdef __WINDOWS__\n"
"\n"
"/* When compiling for windows, we specify a specific calling convention to avoid issues where we are being called from a project with a different default calling convention.  For windows you have 2 define options:\n"
"\n"
"CJSON_HIDE_SYMBOLS - Define this in the case where you don't want to ever dllexport symbols\n"
"CJSON_EXPORT_SYMBOLS - Define this on library build when you want to dllexport symbols (default)\n"
"CJSON_IMPORT_SYMBOLS - Define this if you want to dllimport symbol\n"
"\n"
"For *nix builds that support visibility attribute, you can define similar behavior by\n"
"\n"
"setting default visibility to hidden by adding\n"
"-fvisibility=hidden (for gcc)\n"
"or\n"
"-xldscope=hidden (for sun cc)\n"
"to CFLAGS\n"
"\n"
"then using the CJSON_API_VISIBILITY flag to \"export\" the same symbols the way CJSON_EXPORT_SYMBOLS does\n"
"\n"
"*/\n"
"\n"
"/* export symbols by default, this is necessary for copy pasting the C and header file */\n"
"#if !defined(CJSON_HIDE_SYMBOLS) && !defined(CJSON_IMPORT_SYMBOLS) && !defined(CJSON_EXPORT_SYMBOLS)\n"
"#define CJSON_EXPORT_SYMBOLS\n"
"#endif\n"
"\n"
"#if defined(CJSON_HIDE_SYMBOLS)\n"
"#define CJSON_PUBLIC(type)   type __stdcall\n"
"#elif defined(CJSON_EXPORT_SYMBOLS)\n"
"#define CJSON_PUBLIC(type)   __declspec(dllexport) type __stdcall\n"
"#elif defined(CJSON_IMPORT_SYMBOLS)\n"
"#define CJSON_PUBLIC(type)   __declspec(dllimport) type __stdcall\n"
"#endif\n"
"#else /* !WIN32 */\n"
"#if (defined(__GNUC__) || defined(__SUNPRO_CC) || defined (__SUNPRO_C)) && defined(CJSON_API_VISIBILITY)\n"
"#define CJSON_PUBLIC(type)   __attribute__((visibility(\"default\"))) type\n"
"#else\n"
"#define CJSON_PUBLIC(type) type\n"
"#endif\n"
"#endif\n"
"\n"
"/* Limits how deeply nested arrays/objects can be before cJSON rejects to parse them.\n"
" * This is to prevent stack overflows. */\n"
"#ifndef CJSON_NESTING_LIMIT\n"
"#define CJSON_NESTING_LIMIT 1000\n"
"#endif\n"
"\n"
"/* returns the version of cJSON as a string */\n"
"CJSON_PUBLIC(const char*) cJSON_Version(void);\n"
"\n"
"/* Supply malloc, realloc and free functions to cJSON */\n"
"CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);\n"
"\n"
"/* Memory Management: the caller is always responsible to free the results from all variants of cJSON_Parse (with cJSON_Delete) and cJSON_Print (with stdlib free, cJSON_Hooks.free_fn, or cJSON_free as appropriate). The exception is cJSON_PrintPreallocated, where the caller has full responsibility of the buffer. */\n"
"/* Supply a block of JSON, and this returns a cJSON object you can interrogate. */\n"
"CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);\n"
"/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */\n"
"/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error so will match cJSON_GetErrorPtr(). */\n"
"CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);\n"
"\n"
"/* Render a cJSON entity to text for transfer/storage. */\n"
"CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);\n"
"/* Render a cJSON entity to text for transfer/storage without any formatting. */\n"
"CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);\n"
"/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */\n"
"CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);\n"
"/* Render a cJSON entity to text using a buffer already allocated in memory with given length. Returns 1 on success and 0 on failure. */\n"
"/* NOTE: cJSON is not always 100% accurate in estimating how much memory it will use, so to be safe allocate 5 bytes more than you actually need */\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);\n"
"/* Delete a cJSON entity and all subentities. */\n"
"CJSON_PUBLIC(void) cJSON_Delete(cJSON *c);\n"
"\n"
"/* Returns the number of items in an array (or object). */\n"
"CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);\n"
"/* Retrieve item number \"item\" from array \"array\". Returns NULL if unsuccessful. */\n"
"CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);\n"
"/* Get item \"string\" from object. Case insensitive. */\n"
"CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);\n"
"CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string);\n"
"/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */\n"
"CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);\n"
"\n"
"/* These functions check the type of an item */\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item);\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item);\n"
"\n"
"/* These calls create a cJSON item of the appropriate type. */\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);\n"
"/* raw json */\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw);\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);\n"
"\n"
"/* These utilities create an Array of count items. */\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);\n"
"CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count);\n"
"\n"
"/* Append item to the specified array/object. */\n"
"CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item);\n"
"CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);\n"
"/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object.\n"
" * WARNING: When this function was used, make sure to always check that (item->type & cJSON_StringIsConst) is zero before\n"
" * writing to `item->string` */\n"
"CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);\n"
"/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */\n"
"CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);\n"
"CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);\n"
"\n"
"/* Remove/Detatch items from Arrays/Objects. */\n"
"CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);\n"
"CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which);\n"
"CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which);\n"
"CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string);\n"
"CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);\n"
"CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string);\n"
"CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);\n"
"\n"
"/* Update array items. */\n"
"CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem); /* Shifts pre-existing items to the right. */\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);\n"
"CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);\n"
"CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);\n"
"CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);\n"
"\n"
"/* Duplicate a cJSON item */\n"
"CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);\n"
"/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will\n"
"need to be released. With recurse!=0, it will duplicate any children connected to the item.\n"
"The item->next and ->prev pointers are always zero on return from Duplicate. */\n"
"/* Recursively compare two cJSON items for equality. If either a or b is NULL or invalid, they will be considered unequal.\n"
" * case_sensitive determines if object keys are treated case sensitive (1) or case insensitive (0) */\n"
"CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);\n"
"\n"
"\n"
"CJSON_PUBLIC(void) cJSON_Minify(char *json);\n"
"\n"
"/* Macros for creating things quickly. */\n"
"#define cJSON_AddNullToObject(object,name) cJSON_AddItemToObject(object, name, cJSON_CreateNull())\n"
"#define cJSON_AddTrueToObject(object,name) cJSON_AddItemToObject(object, name, cJSON_CreateTrue())\n"
"#define cJSON_AddFalseToObject(object,name) cJSON_AddItemToObject(object, name, cJSON_CreateFalse())\n"
"#define cJSON_AddBoolToObject(object,name,b) cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))\n"
"#define cJSON_AddNumberToObject(object,name,n) cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))\n"
"#define cJSON_AddStringToObject(object,name,s) cJSON_AddItemToObject(object, name, cJSON_CreateString(s))\n"
"#define cJSON_AddRawToObject(object,name,s) cJSON_AddItemToObject(object, name, cJSON_CreateRaw(s))\n"
"\n"
"/* When assigning an integer value, it needs to be propagated to valuedouble too. */\n"
"#define cJSON_SetIntValue(object, number) ((object) ? (object)->valueint = (object)->valuedouble = (number) : (number))\n"
"/* helper for the cJSON_SetNumberValue macro */\n"
"CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number);\n"
"#define cJSON_SetNumberValue(object, number) ((object != NULL) ? cJSON_SetNumberHelper(object, (double)number) : (number))\n"
"\n"
"/* Macro for iterating over an array or object */\n"
"#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)\n"
"\n"
"/* malloc/free objects using the malloc/free functions that have been set with cJSON_InitHooks */\n"
"CJSON_PUBLIC(void *) cJSON_malloc(size_t size);\n"
"CJSON_PUBLIC(void) cJSON_free(void *object);\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#endif\n";
